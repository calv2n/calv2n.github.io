---
title: Project Portfolio
format:
  html:
    code-links:
      - text: site repository
        href: https://www.github.com/calv2n/calv2n.github.io
        icon: github
---

## Gradebook

**January 1 - May 31**

[https://www.github.com/gradebook-dev/](https://www.github.com/gradebook-dev/)

**Description:** Gradebook is an open-source R package and Web Application that provides a consistent interface for instructors to quickly and more accurately calculate course grades.

**The Problem:** Many instructors (especially at Berkeley) opt to use [Gradescope](https://www.gradescope.com) for students to upload their submissions to course assignments, as it provides an industry leading interface to instructors and readers for grading. However, Gradescope lacks functionality of implimenting a *course policy*. An example of a course policy ([Data 88S](http://stat88.org/syllabus/)):

![](pages/ss-d88s.png)

At first, this might seem like a simple problem to solve with some sort of code file (perhaps using Pandas & NumPy in Python or R). But we have seen with courses such as [Statistics 20](https://www.stat20.org) that these course policies can get extraordinarily convoluted and error prone. 

The current best solution for instructors to calculate final grades based on their course policy is to either of the following:

- Parallel program two seperate code books and compare the scores against one another until they agree.
    - pros: very accurate
    - cons: takes two programmers that fully understand the course policy & takes longer than single code book.
- Create a single code book that can result in potential bugs that result in inaccurate scores.
    - pros: faster than parallel programming
    - cons: error prone and still not a fast solution.

**The Solution:** 

Gradebook: An interface that abstracts the code into human understandable steps.

![](pages/gb.png)

An instructor (or reader) provides the web app with their course policy using the intuitive policy tab. Then, they can upload their course's Gradescope CSV to see data visualizations, statistics, a final grade table, and more.

### What I Learned

During my time with the Gradebook team, I was responsible for designing and developing the "Dashboard" which displays graphics and statistics so the instructor can visually gauge their student's project.

- Applying **Data Visualization** skills using **Plotly**.

- **Git** and **GitHub** (including branching, pull requests, working with github in a team setting).

- The importance of **Teamwork** & **Communication** in Data Science.

- Web development essentials (incl. **HTML**, **CSS**)

## Email Spam Detection

**November 2023, February 2024**

Source code available upon request.

"All models are wrong, but some are useful" - *George Box*

In my time as an undergraduate at Berkeley, I've had a few projects address the famous problem of email spam detection. In my first attempt at creating an accurate solution, I created a **logistic regression** model.

### Logistic Regression

To find the best features for my model, I used exploritory data analysis techniques, including visualization with a heatmap of the feature correlations, bivariate data analysis with data visualization, and filling NA values in features with appropriate aggregations (mean, median, or 0 depending on skew of univariate distribution).

I also used **feature engineering** to get some of the most effective features for my regression. Some of the best features I found were the following:

- Email is a "forwarded" or "reply" **\***.

- Length of subject line in email.

- Overall "wordiness" of email **\***.

- Proportion of capital letters in subject line **\***.

*`*` indicates featured engineering used.*

![](spam-email-logistic-coeff-importance.png)

Resulting ROC Curve:

![](pages/roc-email-spam-logistic.png)

My final **test accuracy** using this model was $\approx$ **87%**.

### Support Vector Machine (SVM)

Used **k-fold cross validation** to optimize C value in `svm.SVC` function found in the scikit-learn package in Python. Eventually landed on a **test accuracy** of **86%** using the `rbf` kernel with a C value of 325.

### What I learned

- **Logistic Regression**, including cross entropy loss, logit function, and interpretation.

- Further developed knowledge of the **scikit-learn** tool basket.

- Soft-margin Support Vector Machines (**SVMs**), who introduces flexibility by allowing some margin violations (compare to hard-margin who don't).


## Diabetes Prediction



## Gitlet

**July 2023**

Source code available upon request.

Successfully implimented the following commands from the Git Version Control System:

- init: Creates a new Gitlet version-control system in the current directory.

- add: Adds a copy of the file as it currently exists to the *staging area*.

- commit: Saves a snapshot of tracked files in the current commit and staging area so they can be restored at a later time, creating a new commit.

- restore: Restore is used to revert files back to their previous versions. Depending on the arguments, there’s 2 different usages of restore:

    1. `java gitlet.Main restore -- [file name]`

    2. `java gitlet.Main restore [commit id] -- [file name]`

- log: Starting at the current head commit, display information about each commit backwards along the commit tree until the initial commit, following the first parent commit links, ignoring any second parents found in merge commits.

```
===
commit a0da1ea5a15ab613bf9961fd86f010cf74c7ee48
Date: Thu Nov 9 20:00:05 2017 -0800
A commit message.

===
commit 3e8bf1d794ca2e9ef8a4007275acf3751c7170ff
Date: Thu Nov 9 17:01:33 2017 -0800
Another commit message.

===
commit e881c9575d180a215d1a636545b8fd9abfb1d2bb
Date: Wed Dec 31 16:00:00 1969 -0800
initial commit
```

- global-log: Like log, except displays information about all commits ever made.

- rm: Unstage the file if it is currently staged for addition. If the file is tracked in the current commit, stage it for removal and remove the file from the working directory if the user has not already done so.

- find: Prints out the ids of all commits that have the given commit message, one per line. If there are multiple such commits, it prints the ids out on separate lines.

- status: Displays what branches currently exist, and marks the current branch with a `*`. Also displays what files have been staged for addition or removal.

- branch: Creates a new branch with the given name, and points it at the current head commit.

- switch: Switches to the branch with the given name. Takes all files in the commit at the head of the given branch, and puts them in the working directory, overwriting the versions of the files that are already there if they exist. Also, at the end of this command, the given branch will now be considered the current branch (HEAD). Any files that are tracked in the current branch but are not present in the checked-out branch are deleted. The staging area is cleared, unless the checked-out branch is the current branch.

- rm-branch: Deletes the branch with the given name. This only means to delete the pointer associated with the branch; it does not mean to delete all commits that were created under the branch, or anything like that.

- reset:  Restores all the files tracked by the given commit. Removes tracked files that are not present in that commit. Also moves the current branch’s head to that commit node.

### What I Learned

This was my first large project when I came to Berkeley as an undergraduate. 

- **Java** for large scale projects

- Designing and implimenting **data structures** to maximize efficiency.

- Fundamentals of **Git** as a software from the ground up.

